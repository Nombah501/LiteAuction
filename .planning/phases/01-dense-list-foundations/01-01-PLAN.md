---
phase: 01-dense-list-foundations
plan: "01"
type: execute
wave: 1
depends_on: []
files_modified:
  - app/db/models.py
  - alembic/versions/0036_admin_list_preferences.py
  - app/services/admin_list_preferences_service.py
  - tests/test_admin_list_preferences_service.py
  - tests/integration/test_web_dense_list_foundations.py
autonomous: true
requirements:
  - DENS-02
  - LAYT-03
must_haves:
  truths:
    - "Preferences for density and column layout are persisted to server storage per admin subject and queue."
    - "The same operator receives saved list preferences after refresh and new authenticated session."
    - "One operator's saved list preferences do not leak to another operator."
  artifacts:
    - path: app/db/models.py
      provides: "AdminListPreference ORM model with unique subject+queue scope and JSONB layout state."
      contains: "class AdminListPreference"
    - path: alembic/versions/0036_admin_list_preferences.py
      provides: "Backward-safe migration creating admin list preferences table and uniqueness indexes."
      contains: "admin_list_preferences"
    - path: app/services/admin_list_preferences_service.py
      provides: "Validated read/upsert API for dense list preferences and subject key derivation."
      exports: ["load_admin_list_preference", "save_admin_list_preference"]
  key_links:
    - from: app/services/admin_list_preferences_service.py
      to: app/db/models.py
      via: "SQLAlchemy insert/on_conflict_do_update and select by subject+queue"
      pattern: "on_conflict_do_update|select\(AdminListPreference"
    - from: alembic/versions/0036_admin_list_preferences.py
      to: app/db/models.py
      via: "Table columns and constraints match ORM contract"
      pattern: "subject_key|queue_key|density|columns_json"
---

<objective>
Create the persistence foundation for dense list preferences so queue density and column layout can survive refreshes and new sessions.

Purpose: De-risk cross-session behavior early by shipping canonical server-side storage before UI controls are wired.
Output: Preference model, migration, and service-level APIs with regression tests.
</objective>

<execution_context>
@/home/n501/.config/opencode/get-shit-done/workflows/execute-plan.md
@/home/n501/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-dense-list-foundations/01-RESEARCH.md
@app/db/models.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add admin list preference persistence schema</name>
  <files>app/db/models.py, alembic/versions/0036_admin_list_preferences.py</files>
  <action>Add an `AdminListPreference` model keyed by `subject_key` + `queue_key` with `density` (`compact|standard|comfortable`) and `columns_json` JSONB payload for `{visible, order, pinned}`. Create Alembic migration `0036_admin_list_preferences.py` that adds the table, unique constraint, and helpful lookup indexes, and keeps downgrade path intact for rollback safety.</action>
  <verify>alembic upgrade head && alembic downgrade -1 && alembic upgrade head</verify>
  <done>Schema applies and rolls back cleanly; table and uniqueness constraints exist exactly once.</done>
</task>

<task type="auto">
  <name>Task 2: Implement validated preference read/write service</name>
  <files>app/services/admin_list_preferences_service.py</files>
  <action>Create service functions that normalize subject identity from existing admin auth context, validate density and column keys against an allow-list, and persist preferences via atomic PostgreSQL upsert. Reject invalid density/column payloads with `ValueError` instead of silently storing malformed state to preserve auditability and deterministic rendering.</action>
  <verify>python -m pytest -q tests/test_admin_list_preferences_service.py</verify>
  <done>Service can load defaults when no row exists, upsert valid state, and reject invalid payloads.</done>
</task>

<task type="auto">
  <name>Task 3: Add persistence-focused regression coverage</name>
  <files>tests/test_admin_list_preferences_service.py, tests/integration/test_web_dense_list_foundations.py</files>
  <action>Add unit tests for parser/validator behavior (density enum, visible/order/pinned constraints, unknown columns) and DB-backed integration tests that prove same-subject persistence plus cross-subject isolation. Keep tests scoped to persistence behavior only; UI rendering checks belong to later plans.</action>
  <verify>RUN_INTEGRATION_TESTS=1 TEST_DATABASE_URL=postgresql+asyncpg://.../auction_test python -m pytest -q tests/test_admin_list_preferences_service.py tests/integration/test_web_dense_list_foundations.py -k preferences</verify>
  <done>Tests fail on malformed payloads and pass for persisted/restored preferences per subject+queue scope.</done>
</task>

</tasks>

<verification>
Run migration round-trip and targeted unit/integration tests for persistence behavior.
</verification>

<success_criteria>
Admin list preference storage exists, validates payloads, and proves cross-session/cross-subject behavior through automated tests.
</success_criteria>

<output>
After completion, create `.planning/phases/01-dense-list-foundations/01-dense-list-foundations-01-SUMMARY.md`
</output>
